<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mapillary: HKocen pins after date (no clustering)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- MapillaryJS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.css" />
  <script src="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.min.js"></script>
  <!-- MapLibre GL -->
  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <style>
    html, body { height: 100%; margin: 0; }
    #wrap { position: relative; height: 100vh; width: 100%; }
    #viewer, #map { position: absolute; top: 0; height: 100%; }
    #viewer { left: 0; width: 61.8%; }
    #map    { right: 0; width: calc(38.2% - 2px); }
    #msg {
      position: absolute; left: 8px; top: 8px; z-index: 1000;
      background: rgba(0,0,0,.7); color:#fff; padding:6px 10px; border-radius:6px;
      font: 13px/1.3 system-ui, sans-serif;
      max-width: min(48vw, 720px);
      white-space: pre-line;
    }
    #msg.error { background: rgba(160, 0, 0, .85); }
    #controls {
      position: absolute; right: 8px; top: 8px; z-index: 1000;
      background: rgba(255,255,255,.9); color:#222; padding: 6px 8px; border-radius: 6px;
      font: 13px/1.3 system-ui, sans-serif; display: flex; gap: 6px; align-items: center;
      box-shadow: 0 2px 10px rgba(0,0,0,.15);
    }
    #controls input { padding: 3px 6px; font: inherit; }
    #controls button { padding: 4px 8px; font: inherit; cursor: pointer; }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="viewer"></div>
    <div id="map"></div>
    <div id="msg">Loading…</div>
    <div id="controls">
      <label for="after">After (UTC):</label>
      <input id="after" type="date" />
      <button id="apply">Apply</button>
      <span id="count"></span>
    </div>
  </div>

  <script>
    // ===== Config =====
    const TOKEN     = "MLY|24840280672250420|6fc0e204403850a11ccc043866f1b01d";
    const START_ID  = "744575191439794";
    const USERNAME  = "HKocen";
    const MAX_IMAGES = 10000;
    const PAGE_LIMIT = 1000;

    // Read ?after=YYYY-MM-DD (optional). Default to 2025-06-01 if not set.
    const qs = new URLSearchParams(location.search);
    const afterParam = qs.get("after"); // e.g., 2025-05-01
    const DEFAULT_AFTER = "2025-06-01";
    const afterDateStr = /^\d{4}-\d{2}-\d{2}$/.test(afterParam || "") ? afterParam : DEFAULT_AFTER;
    const CUTOFF_ISO = afterDateStr + "T00:00:00Z";

    // Status helpers
    const $msg = document.getElementById("msg");
    const $count = document.getElementById("count");
    function status(t, isError=false) {
      $msg.textContent = t || "";
      $msg.classList.toggle("error", !!isError);
    }
    function setCount(n){ $count.textContent = n!=null ? `Count: ${n}` : ""; }

    // Wire the little date control (also updates the URL so you can bookmark/share)
    const $afterInput = document.getElementById("after");
    $afterInput.value = afterDateStr;
    document.getElementById("apply").addEventListener("click", ()=>{
      const d = $afterInput.value;
      if (!/^\d{4}-\d{2}-\d{2}$/.test(d)) { alert("Use format YYYY-MM-DD"); return; }
      const u = new URL(location.href);
      u.searchParams.set("after", d);
      location.href = u.toString();
    });

    // ===== Viewer (left) =====
    const viewer = new mapillary.Viewer({
      container: "viewer",
      accessToken: TOKEN,
      imageId: START_ID,
      component: { cover: false, direction: true, zoom: true, attribution: true }
    });

    // Small camera wedge + position marker on the map
    function makeArcPath(fovDeg) {
      const radius = 45, cx = 50, cy = 50, rad = Math.PI/180 * fovDeg;
      const a0 = -Math.PI/2 - rad/2, a1 = a0 + rad;
      const x0 = cx + radius * Math.cos(a0), y0 = cy + radius * Math.sin(a0);
      const x1 = cx + radius * Math.cos(a1), y1 = cy + radius * Math.sin(a1);
      return `M ${cx} ${cy} L ${x0} ${y0} A ${radius} ${radius} 0 0 1 ${x1} ${y1} Z`;
    }
    function makeCamera(bearingDeg, fovDeg) {
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('d', makeArcPath(fovDeg));
      path.setAttribute('fill','yellow'); path.setAttribute('fill-opacity','0.5');
      path.setAttribute('stroke','black'); path.setAttribute('stroke-width','1'); path.setAttribute('stroke-linejoin','round');
      const svg = document.createElementNS('http://www.w3.org/2000/svg','svg'); svg.setAttribute('viewBox','0 0 100 100'); svg.appendChild(path);
      svg.style.height='100%'; svg.style.width='100%'; svg.style.transform = `rotateZ(${bearingDeg}deg)`;
      const el = document.createElement('div'); el.style.height='200px'; el.style.width='200px'; el.appendChild(svg);
      return el;
    }

    // ===== Map (right) =====
    const OSM_RASTER_STYLE = {
      "version": 8,
      "name": "OSM Raster",
      "glyphs": "https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf",
      "sources": {
        "osm": {
          "type": "raster",
          "tiles": ["https://tile.openstreetmap.org/{z}/{x}/{y}.png"],
          "tileSize": 256, "minzoom": 0, "maxzoom": 19,
          "attribution": "© OpenStreetMap contributors"
        }
      },
      "layers": [
        { "id": "bg", "type": "background", "paint": { "background-color": "#e6f2d8" } },
        { "id": "osm", "type": "raster", "source": "osm" }
      ]
    };

    const map = new maplibregl.Map({
      container: "map",
      style: OSM_RASTER_STYLE,
      center: [-91.965153, 30.138307],
      zoom: 5
    });

    const cameraEl = makeCamera(0, 90);
    const cameraMarker = new maplibregl.Marker({ element: cameraEl, rotationAlignment: "map" });
    const posDot = document.createElement('div');
    posDot.style.cssText="width:14px;height:14px;border:3px solid #ff2a6d;border-radius:50%;background:#fff9";
    const positionMarker = new maplibregl.Marker({ element: posDot, rotationAlignment: "map" });

    async function syncPosition() {
      try {
        const p = await viewer.getPosition();
        const pov = await viewer.getPointOfView();
        positionMarker.setLngLat([p.lng, p.lat]).addTo(map);
        cameraMarker.setLngLat([p.lng, p.lat]).addTo(map);
        cameraEl.querySelector('svg').style.transform = `rotateZ(${pov.bearing}deg)`;
      } catch {}
    }
    viewer.on('load', syncPosition);
    viewer.on('image', syncPosition);
    viewer.on('position', syncPosition);
    viewer.on('pov',     syncPosition);
    viewer.on('fov', async () => {
      const vc = viewer.getContainer();
      const vFov = Math.PI/180 * (await viewer.getFieldOfView());
      const aspect = vc.offsetHeight ? vc.offsetWidth / vc.offsetHeight : 0;
      const hFovDeg = Math.atan(aspect * Math.tan(0.5*vFov)) * 2 * 180/Math.PI;
      cameraEl.querySelector('path').setAttribute('d', makeArcPath(hFovDeg));
    });
    window.addEventListener('resize', ()=>viewer.emit && viewer.emit('fov'));

    // ===== Fetch ALL images by user (paged), filtered by captured_at >= CUTOFF_ISO =====
    async function fetchAllImagesByUser(username, maxImages = MAX_IMAGES) {
      const attempt = async (paramKey) => {
        const cutoffMs = Date.parse(CUTOFF_ISO);
        let out = [];
        let url = new URL("https://graph.mapillary.com/images");
        url.searchParams.set("fields", "id,computed_geometry,captured_at");
        url.searchParams.set(paramKey, username);                 // usernames=... or creator_username=...
        url.searchParams.set("start_captured_at", CUTOFF_ISO);    // server-side date filter
        url.searchParams.set("limit", String(Math.min(PAGE_LIMIT, maxImages)));
        url.searchParams.set("access_token", TOKEN);

        while (url && out.length < maxImages) {
          status(`Fetching (>= ${CUTOFF_ISO}) for ${username}… ${out.length} fetched`);
          const res = await fetch(url);
          if (!res.ok) {
            const t = await res.text().catch(()=>res.statusText);
            throw new Error(`API ${res.status}: ${t}`);
          }
          const j = await res.json();
          const data = Array.isArray(j.data) ? j.data : [];
          for (const d of data) {
            const c = d?.computed_geometry?.coordinates;
            const ts = d?.captured_at ? Date.parse(d.captured_at) : NaN;
            if (!Array.isArray(c) || c.length !== 2) continue;
            if (!Number.isNaN(ts) && ts < cutoffMs) continue; // extra local guard
            out.push({ id: d.id, lng: c[0], lat: c[1], captured_at: d.captured_at || "" });
            if (out.length >= maxImages) break;
          }
          const next = j?.paging?.next;
          if (next && out.length < maxImages) {
            url = new URL(next);
            if (!url.searchParams.get("access_token"))       url.searchParams.set("access_token", TOKEN);
            if (!url.searchParams.get(paramKey))             url.searchParams.set(paramKey, username);
            if (!url.searchParams.get("fields"))             url.searchParams.set("fields", "id,computed_geometry,captured_at");
            if (!url.searchParams.get("start_captured_at"))  url.searchParams.set("start_captured_at", CUTOFF_ISO);
          } else {
            url = null;
          }
        }
        return out;
      };

      // Try modern filter first, then fallback
      let items = await attempt("usernames");
      if (items.length === 0) items = await attempt("creator_username");
      status(`Pins loaded (>= ${CUTOFF_ISO}): ${items.length}`);
      setCount(items.length);
      return items;
    }

    // ===== Render pins (no clustering) =====
    function addPinsToMap(items) {
      const features = items.map(it => ({
        type: "Feature",
        geometry: { type: "Point", coordinates: [it.lng, it.lat] },
        properties: { id: it.id, captured_at: it.captured_at }
      }));
      const geojson = { type: "FeatureCollection", features };

      if (map.getLayer("pins-dots")) map.removeLayer("pins-dots");
      if (map.getSource("pins")) map.removeSource("pins");

      map.addSource("pins", { type: "geojson", data: geojson });

      map.addLayer({
        id: "pins-dots",
        type: "circle",
        source: "pins",
        paint: {
          "circle-color": "#1b5e20",
          "circle-opacity": 0.95,
          "circle-radius": ["interpolate", ["linear"], ["zoom"], 3, 2, 8, 3, 12, 4, 19, 6],
          "circle-stroke-width": 2,
          "circle-stroke-color": "#9cff9c"
        }
      });

      map.on("click", "pins-dots", (e) => {
        const f = map.queryRenderedFeatures(e.point, { layers: ["pins-dots"] })[0];
        if (f?.properties?.id) viewer.moveTo(f.properties.id).catch(()=>{});
      });
      map.on("mouseenter", "pins-dots", ()=> map.getCanvas().style.cursor = "pointer");
      map.on("mouseleave", "pins-dots", ()=> map.getCanvas().style.cursor = "");

      if (features.length) {
        const b = new maplibregl.LngLatBounds(features[0].geometry.coordinates, features[0].geometry.coordinates);
        for (const ft of features) b.extend(ft.geometry.coordinates);
        map.fitBounds(b, { padding: 30, maxZoom: 12 });
        status(`Showing ${features.length} pins (after ${CUTOFF_ISO})`);
      } else {
        status(`No pins found for ${USERNAME} after ${CUTOFF_ISO}. Try an earlier date via ?after=YYYY-MM-DD or the control at top-right.`, true);
      }
    }

    function addPinsWhenReady(items) {
      if (map.loaded() || map.isStyleLoaded?.()) addPinsToMap(items);
      else map.once("load", () => addPinsToMap(items));
    }

    // ===== Boot =====
    (async () => {
      try {
        status(`Cutoff: ${CUTOFF_ISO}\nFetching images…`);
        const items = await fetchAllImagesByUser(USERNAME, MAX_IMAGES);
        addPinsWhenReady(items);
      } catch (err) {
        console.error(err);
        status(`Failed to load pins: ${err.message || err}`, true);
      }
    })();
  </script>
</body>
</html>
