<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>MapillaryJS – split viewer/map w/ safe bbox tiling</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- MapillaryJS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.css" />
  <script src="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.min.js"></script>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #wrap { height: 100vh; width: 100%; display:grid; grid-template-columns:1fr 1fr; }
    #mly, #map { height: 100%; width: 100%; }
    #msg { position: absolute; top: 8px; left: 8px; z-index: 1000;
           background: rgba(0,0,0,.6); color: #fff; padding: 6px 10px; border-radius: 6px;
           font: 13px/1.4 system-ui, sans-serif; }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="mly" aria-label="Mapillary viewer"></div>
    <div id="map" aria-label="Map"></div>
    <div id="msg"></div>
  </div>

  <script>
    // ====== CONFIG ======
    const TOKEN      = "MLY|24840280672250420|6fc0e204403850a11ccc043866f1b01d";
    const START_ID   = "744575191439794";
    const USERNAME   = "HKocen";

    // Mapillary Graph limits: < 0.001 deg^2 (strict). Use a safety margin.
    const MAX_TILE_AREA = 0.0008;                  // deg^2
    const MIN_ZOOM_FOR_PINS = 16;                  // require zoom-in before fetching
    const PER_TILE_LIMIT = 200;                    // keep it reasonable

    // ====== UI helpers ======
    const status = (t)=>{ document.getElementById('msg').textContent = t || ""; };

    // ====== MAP ======
    const map = L.map('map', { zoomControl:true }).setView([30.138307, -91.965153], 15);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, attribution: '&copy; OpenStreetMap'
    }).addTo(map);
    const pinLayer = L.layerGroup().addTo(map);
    const cursor = L.circleMarker([0,0], { radius: 8, weight: 3 }).addTo(map);

    // ====== VIEWER ======
    const viewer = new mapillary.Viewer({
      container: "mly",
      accessToken: TOKEN,
      imageId: START_ID,
      component: { cover: true, direction: true, zoom: true, attribution: true }
    });

    // Keep map centered on the active image
    viewer.on("image", async e => {
      const id = e?.imageId || e?.image?.id;
      if (!id) return;
      const ll = await getImageLatLng(id);
      if (ll) {
        cursor.setLatLng(ll);
        if (!map.getBounds().pad(-0.2).contains(ll)) {
          map.setView(ll, Math.max(map.getZoom(), 16));
        }
      }
      // highlight pin if present
      const lyr = pinsById.get(id);
      if (lyr) {
        if (selectedPin && selectedPin !== lyr) try { selectedPin.setStyle(defaultPinStyle); } catch {}
        try { lyr.setStyle(selectedPinStyle); lyr.bringToFront(); } catch {}
        selectedPin = lyr;
      }
    });

    // ====== Graph helpers ======
    async function getImageLatLng(imageId) {
      const u = new URL(`https://graph.mapillary.com/${imageId}`);
      u.searchParams.set("fields", "computed_geometry");
      const res = await fetch(u, { headers: { Authorization: `OAuth ${TOKEN}` }});
      if (!res.ok) return null;
      const j = await res.json();
      const c = j?.computed_geometry?.coordinates;
      return (Array.isArray(c) && c.length === 2) ? [c[1], c[0]] : null;
    }

    // ====== BBOX tiling (to satisfy < 0.001 deg²) ======
    function bboxFromMap(m) {
      const b = m.getBounds();
      const sw = b.getSouthWest(), ne = b.getNorthEast();
      return [sw.lng, sw.lat, ne.lng, ne.lat];      // [w,s,e,n]
    }
    function bboxAreaDeg2([w,s,e,n]) { return Math.max(0, (e-w)) * Math.max(0, (n-s)); }
    function splitBbox([w,s,e,n]) {
      const midX = (w+e)/2, midY = (s+n)/2;
      return [
        [w,    s,    midX, midY],   // SW
        [midX, s,    e,    midY],   // SE
        [w,    midY, midX, n   ],   // NW
        [midX, midY, e,    n   ]    // NE
      ];
    }
    function tileBboxes(bbox, maxArea = MAX_TILE_AREA, maxTiles = 64) {
      const out = [];
      const q = [bbox];
      while (q.length && out.length < maxTiles) {
        const b = q.shift();
        if (bboxAreaDeg2(b) < maxArea) { out.push(b); continue; }
        const parts = splitBbox(b);
        // If splitting doesn’t reduce (degenerate bounds), stop
        if (parts.some(p => bboxAreaDeg2(p) === 0)) { out.push(b); continue; }
        q.push(...parts);
      }
      return out;
    }

    async function fetchImagesForTile(bbox, limit = PER_TILE_LIMIT) {
      const url = new URL("https://graph.mapillary.com/images");
      url.searchParams.set("fields", "id,computed_geometry");
      url.searchParams.set("bbox", bbox.join(","));
      url.searchParams.set("limit", String(limit));
      if (USERNAME) url.searchParams.set("creator_username", USERNAME);

      const res = await fetch(url, { headers: { Authorization: `OAuth ${TOKEN}` }});
      if (!res.ok) {
        const t = await res.text().catch(() => res.statusText);
        throw new Error(`API ${res.status}: ${t}`);
      }
      const j = await res.json();
      return Array.isArray(j.data) ? j.data : [];
    }

    // ====== Pins drawing with tiling + zoom guard ======
    const defaultPinStyle  = { radius: 4, color: '#1b5e20', weight: 2, fillColor: '#2ecc71', fillOpacity: 0.9 };
    const selectedPinStyle = { radius: 8, color: '#e53935', weight: 3, fillColor: '#ffcdd2', fillOpacity: 1.0 };
    let pinsById = new Map();
    let selectedPin = null;

    async function drawPinsForView() {
      if (map.getZoom() < MIN_ZOOM_FOR_PINS) {
        status(`Zoom in (≥ ${MIN_ZOOM_FOR_PINS}) to load pins`);
        pinLayer.clearLayers();
        pinsById.clear();
        selectedPin = null;
        return;
      }

      const viewBox = bboxFromMap(map);
      const tiles = tileBboxes(viewBox, MAX_TILE_AREA);
      status(`Loading pins… (${tiles.length} tile${tiles.length>1?'s':''})`);

      const idSeen = new Set();
      const features = [];

      for (const t of tiles) {
        try {
          const images = await fetchImagesForTile(t, PER_TILE_LIMIT);
          for (const img of images) {
            const c = img?.computed_geometry?.coordinates;
            if (!c) continue;
            if (idSeen.has(img.id)) continue;
            idSeen.add(img.id);
            features.push({ id: img.id, lat: c[1], lng: c[0] });
          }
        } catch (err) {
          console.warn("Tile fetch failed:", err.message);
          // keep going — other tiles may succeed
        }
      }

      // Render pins
      pinLayer.clearLayers();
      pinsById.clear();
      selectedPin = null;

      for (const f of features) {
        const pin = L.circleMarker([f.lat, f.lng], defaultPinStyle)
          .on('click', () => viewer.moveTo(f.id))
          .addTo(pinLayer);
        pin.bindTooltip(`Image ${f.id}`);
        pinsById.set(f.id, pin);
      }
      status(`Pins: ${features.length}`);
    }

    // Debounced refresh on map move
    let pinTimer = null;
    map.on('moveend', () => {
      clearTimeout(pinTimer);
      pinTimer = setTimeout(drawPinsForView, 250);
    });

    // First center + initial pins
    (async () => {
      // Center map on start image location (and cursor)
      try {
        const ll = await getImageLatLng(START_ID);
        if (ll) {
          cursor.setLatLng(ll);
          map.setView(ll, Math.max(map.getZoom(), 16));
        }
      } catch {}
      // Initial load
      drawPinsForView();
    })();
  </script>
</body>
</html>
