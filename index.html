<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>MapillaryJS – image + map (with user pins)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- MapillaryJS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.css" />
  <script src="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.min.js"></script>

  <!-- Leaflet (OSM tiles) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #wrap { height: 100vh; width: 100%; }
    #mly, #map { height: 100%; width: 100%; }
    #msg { position: absolute; top: 8px; left: 8px; z-index: 1000;
           background: rgba(0,0,0,0.6); color: #fff; padding: 6px 10px; border-radius: 6px;
           font: 13px/1.4 system-ui, sans-serif; }
    /* Layouts */
    .image-only { display: block; position: relative; }
    .image-only #map { display: none; }
    .map-only   { display: block; }
    .map-only   #mly { display: none; }
    .split      { display: grid; grid-template-columns: 1fr 1fr; }
    .split #mly, .split #map { display: block; }
  </style>
</head>
<body>
  <div id="wrap" class="image-only">
    <div id="mly" aria-label="Mapillary viewer"></div>
    <div id="map" aria-label="Map"></div>
    <div id="msg"></div>
  </div>

  <script>
    const qs = new URLSearchParams(location.search);
    const TOKEN = qs.get("token") || ""; // Mapillary token via ?token=...
    const defaults = {
      lat: Number(qs.get("lat") ?? 30.145619851543174),
      lng: Number(qs.get("lng") ?? -91.87748325231672),
      z:   Number(qs.get("z")   ?? 11.4),
      username: (qs.get("username") || "HKocen").trim()
    };
    const VIEW = (qs.get("view") || "image").toLowerCase(); // image | map | split
    const SHOW_PINS = (qs.get("pins") || "").toLowerCase() === "all"; // pins=all to draw all images in view

    const status = (t) => { document.getElementById('msg').textContent = t || ""; };

    // Set layout
    const wrap = document.getElementById('wrap');
    wrap.className = VIEW === 'split' ? 'split' : (VIEW === 'map' ? 'map-only' : 'image-only');

    // Rough map zoom -> search radius (meters)
    const zoomToMeters = (z) => 500000 / Math.pow(2, z);

    // --- Leaflet map ---
    const map = L.map('map', { zoomControl: true, attributionControl: true });
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const startLatLng = [defaults.lat, defaults.lng];
    map.setView(startLatLng, 13);

    const marker = L.marker(startLatLng, { draggable: false }).addTo(map);
    const pinLayer = L.layerGroup().addTo(map);  // holds all user image points

    // --- Mapillary helpers ---
    function bboxFromMap(m) {
      const b = m.getBounds();
      const sw = b.getSouthWest(); // lat,lng
      const ne = b.getNorthEast();
      // API expects bbox = minLon,minLat,maxLon,maxLat
      return [sw.lng, sw.lat, ne.lng, ne.lat];
    }

    async function findImageNear({lat, lng}) {
      const url = new URL("https://graph.mapillary.com/images");
      url.searchParams.set("fields", "id,sequence_id,computed_geometry");
      url.searchParams.set("closeto", `${lng},${lat}`);
      url.searchParams.set("radius", Math.max(25, Math.round(zoomToMeters(defaults.z))));
      url.searchParams.set("limit", "1");
      if (defaults.username) url.searchParams.set("creator_username", defaults.username);

      const res = await fetch(url, { headers: { Authorization: `OAuth ${TOKEN}` }});
      if (!res.ok) throw new Error(`API error ${res.status}`);
      const data = await res.json();
      return data?.data?.[0] ?? null;
    }

    // Fetch ALL images for the username within current bbox (paged)
    async function fetchImagesInBbox({bbox, cap=3000}) {
      const base = "https://graph.mapillary.com/images";
      let url = new URL(base);
      url.searchParams.set("fields", "id,computed_geometry");
      url.searchParams.set("bbox", bbox.join(","));
      url.searchParams.set("limit", "100"); // page size
      if (defaults.username) url.searchParams.set("creator_username", defaults.username);

      const out = [];
      while (url && out.length < cap) {
        const res = await fetch(url, { headers: { Authorization: `OAuth ${TOKEN}` }});
        if (!res.ok) throw new Error(`API error ${res.status}`);
        const j = await res.json();
        if (Array.isArray(j.data)) out.push(...j.data);
        const next = j?.paging?.next;
        if (!next) break;
        url = new URL(next);
      }
      return out;
    }

    // Draw pins for all images in bbox
    async function drawPinsForView() {
      if (!TOKEN || !SHOW_PINS) return;
      const bbox = bboxFromMap(map);
      status("Loading user pins in view…");
      try {
        const images = await fetchImagesInBbox({ bbox });
        pinLayer.clearLayers();
        for (const img of images) {
          const coords = img?.computed_geometry?.coordinates; // [lon, lat]
          if (!coords) continue;
          const latlng = [coords[1], coords[0]];
          const c = L.circleMarker(latlng, { radius: 3, weight: 1, opacity: 0.9, fillOpacity: 0.6 });
          c.on('click', () => {
            // If viewer exists, move to this image
            if (viewer) { viewer.moveTo(img.id); }
          });
          c.addTo(pinLayer);
        }
        status(images.length ? `Pins: ${images.length}` : "No images in view for this user.");
      } catch (e) {
        console.error(e);
        status("Error loading pins.");
      }
    }

    // Re-query pins when you pan/zoom (debounced)
    let pinTimer = null;
    map.on('moveend', () => {
      if (!SHOW_PINS) return;
      clearTimeout(pinTimer);
      pinTimer = setTimeout(drawPinsForView, 350);
    });

    // Map click -> jump to nearest image
    map.on('click', async (e) => {
      if (!TOKEN) { status("Add ?token=... to enable image navigation."); return; }
      try {
        status("Finding image near map click…");
        const img = await findImageNear({ lat: e.latlng.lat, lng: e.latlng.lng });
        if (img) {
          await viewer.moveTo(img.id);
          status("");
        } else {
          status("No image found near that point for this user.");
        }
      } catch (err) {
        console.error(err);
        status("Error searching for image near click.");
      }
    });

    // --- Mapillary viewer (only if token present) ---
    let viewer = null;
    (async function init(){
      if (!TOKEN) {
        status(SHOW_PINS ? "Add ?token=YOUR_TOKEN to enable navigation; pins will not load without a token." :
                           "Map only: add ?view=split (or image) and ?token=YOUR_TOKEN to enable the viewer.");
        return;
      }

      const M = window.Mapillary || window.mapillary || window.mapillaryjs;
      const ViewerCtor = M && M.Viewer;
      if (!ViewerCtor) { status("Mapillary library failed to load."); return; }

      viewer = new ViewerCtor({ container: "mly", accessToken: TOKEN });

      try {
        status("Searching for a nearby image…");
        const start = await findImageNear({ lat: defaults.lat, lng: defaults.lng });
        if (!start) { status(`No imagery by "${defaults.username}" near ${defaults.lat.toFixed(5)}, ${defaults.lng.toFixed(5)}.`); return; }

        await viewer.moveTo(start.id);
        status("");

        // Keep navigation to that user's imagery (fallback to sequence)
        try { await viewer.setFilter(["==", "creatorUsername", defaults.username]); }
        catch { /* ignore if property not available */ }

        viewer.setFieldOfView(45); // optional “zoom”

        // Sync map to current image
        async function syncMap(imageId) {
          try {
            const url = new URL(`https://graph.mapillary.com/${imageId}`);
            url.searchParams.set("fields", "computed_geometry");
            const res = await fetch(url, { headers: { Authorization: `OAuth ${TOKEN}` }});
            if (!res.ok) return;
            const j = await res.json();
            const coords = j?.computed_geometry?.coordinates; // [lon, lat]
            if (coords && coords.length === 2) {
              const latlng = [coords[1], coords[0]];
              marker.setLatLng(latlng);
              if (VIEW !== 'image') map.setView(latlng, map.getZoom(), { animate: true });
            }
          } catch {}
        }

        await syncMap(start.id);

        try {
          viewer.on('image', (ev) => {
            const id = ev?.image?.id || ev?.imageId || ev?.id;
            if (id) syncMap(id);
          });
        } catch {
          setInterval(async () => {
            try {
              const state = await viewer.getState?.();
              const id = state?.imageId;
              if (id) syncMap(id);
            } catch {}
          }, 1500);
        }

        // Initial pins load (if requested)
        if (SHOW_PINS) drawPinsForView();

      } catch (e) {
        console.error(e);
        status("Error: " + (e?.message || e));
      }
    })();
  </script>
</body>
</html>
