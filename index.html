<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>MapillaryJS – map wedge from viewer compass</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- MapillaryJS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.css" />
  <script src="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.min.js"></script>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #wrap { height: 100vh; width: 100%; }
    #mly, #map { height: 100%; width: 100%; }
    #msg { position: absolute; top: 8px; left: 8px; z-index: 1000;
           background: rgba(0,0,0,0.6); color: #fff; padding: 6px 10px; border-radius: 6px;
           font: 13px/1.4 system-ui, sans-serif; }
    #dbg { position: absolute; top: 8px; right: 8px; z-index: 1000;
           background: rgba(20,20,20,0.72); color: #9ef; padding: 6px 10px; border-radius: 6px;
           font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; display:none; }
    .image-only { display: block; position: relative; }
    .image-only #map { display: none; }
    .map-only   { display: block; }
    .map-only   #mly { display: none; }
    .split      { display: grid; grid-template-columns: 1fr 1fr; }
    .split #mly, .split #map { display: block; }
  </style>
</head>
<body>
  <div id="wrap" class="image-only">
    <div id="mly" aria-label="Mapillary viewer"></div>
    <div id="map" aria-label="Map"></div>
    <div id="msg"></div>
    <pre id="dbg"></pre>
  </div>

  <script>
    const qs = new URLSearchParams(location.search);
    const TOKEN = qs.get("token") || "";
    const defaults = {
      lat: Number(qs.get("lat") ?? 30.147146),
      lng: Number(qs.get("lng") ?? -91.961231),
      z:   Number(qs.get("z")   ?? 12),
      username: (qs.get("username") || "HKocen").trim()
    };
    const VIEW = (qs.get("view") || "image").toLowerCase();   // image | map | split
    const SHOW_PINS = (qs.get("pins") || "").toLowerCase() === "all";
    const FOV_DEG_DEFAULT = Number(qs.get("fov") ?? 60);      // wedge width & viewer start FOV
    const DEBUG = qs.get("debug") === "1";

    const status = (t) => { document.getElementById('msg').textContent = t || ""; };
    const dbg    = (t) => { const el = document.getElementById('dbg'); if (DEBUG) { el.style.display='block'; el.textContent = t; } };

    // Layout
    const wrap = document.getElementById('wrap');
    wrap.className = VIEW === 'split' ? 'split' : (VIEW === 'map' ? 'map-only' : 'image-only');

    // Map
    const map = L.map('map', { zoomControl: true, attributionControl: true });
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
    const startLatLng = [defaults.lat, defaults.lng];
    map.setView(startLatLng, 13);

    const marker = L.marker(startLatLng, { draggable: false }).addTo(map);
    const pinLayer = L.layerGroup().addTo(map);
    const orientationLayer = L.layerGroup().addTo(map);

    // Pins (green)
    const defaultPinStyle = {
      radius: 4, color: '#1b5e20', weight: 2, opacity: 1,
      fillColor: '#2ecc71', fillOpacity: 0.9, className: 'pin'
    };

    // --- Helpers ---
    function bboxFromMap(m) {
      const b = m.getBounds(), sw = b.getSouthWest(), ne = b.getNorthEast();
      return [sw.lng, sw.lat, ne.lng, ne.lat];
    }
    function zoomToMeters(z) { return 500000 / Math.pow(2, z); }

    // Destination point from (lat,lng) with bearing & distance (meters)
    function destPoint(lat, lng, bearingDeg, meters) {
      const R = 6371000, br = bearingDeg * Math.PI / 180;
      const φ1 = lat * Math.PI / 180, λ1 = lng * Math.PI / 180, δ = meters / R;
      const φ2 = Math.asin(Math.sin(φ1) * Math.cos(δ) + Math.cos(φ1) * Math.sin(δ) * Math.cos(br));
      const λ2 = λ1 + Math.atan2(Math.sin(br) * Math.sin(δ) * Math.cos(φ1), Math.cos(δ) - Math.sin(φ1) * Math.sin(φ2));
      return [φ2 * 180 / Math.PI, ((λ2 * 180 / Math.PI + 540) % 360) - 180];
    }

    function drawOrientation(lat, lng, bearingDeg, fovDeg = FOV_DEG_DEFAULT, length = 50) {
      orientationLayer.clearLayers();
      if (typeof bearingDeg !== 'number') return;
      const left = bearingDeg - fovDeg / 2;
      const right = bearingDeg + fovDeg / 2;
      const tip   = destPoint(lat, lng, bearingDeg, length);
      const pLeft = destPoint(lat, lng, left,    length);
      const pRight= destPoint(lat, lng, right,   length);
      L.polygon([[lat, lng], pLeft, pRight], { color:'#1976d2', weight:1, fillColor:'#1976d2', fillOpacity:0.18 }).addTo(orientationLayer);
      L.polyline([[lat, lng], tip], { color:'#1976d2', weight:2, opacity:0.9 }).addTo(orientationLayer);
    }

    // Mapillary API helpers
    async function findImageNear({lat, lng}) {
      const url = new URL("https://graph.mapillary.com/images");
      url.searchParams.set("fields","id,computed_geometry");
      url.searchParams.set("closeto", `${lng},${lat}`);
      url.searchParams.set("radius", Math.max(25, Math.round(zoomToMeters(defaults.z))));
      url.searchParams.set("limit","1");
      if (defaults.username) url.searchParams.set("creator_username", defaults.username);
      const res = await fetch(url, { headers:{ Authorization:`OAuth ${TOKEN}` }});
      if (!res.ok) throw new Error(`API ${res.status}`);
      const j = await res.json();
      return j?.data?.[0] ?? null;
    }
    async function fetchImagesInBbox({bbox, cap=1500}) {
      let url = new URL("https://graph.mapillary.com/images");
      url.searchParams.set("fields","id,computed_geometry");
      url.searchParams.set("bbox", bbox.join(","));
      url.searchParams.set("limit","100");
      if (defaults.username) url.searchParams.set("creator_username", defaults.username);
      const out = [];
      while (url && out.length < cap) {
        const res = await fetch(url, { headers:{ Authorization:`OAuth ${TOKEN}` }});
        if (!res.ok) throw new Error(`API ${res.status}`);
        const j = await res.json();
        if (Array.isArray(j.data)) out.push(...j.data);
        const next = j?.paging?.next;
        if (!next) break;
        url = new URL(next);
      }
      return out;
    }

    async function drawPinsForView() {
      if (!TOKEN || !SHOW_PINS) return;
      status("Loading user pins in view…");
      try {
        const images = await fetchImagesInBbox({ bbox: bboxFromMap(map) });
        pinLayer.clearLayers();
        for (const img of images) {
          const c = img?.computed_geometry?.coordinates;
          if (!c) continue;
          const latlng = [c[1], c[0]];
          const m = L.circleMarker(latlng, defaultPinStyle);
          m.on('click', (e) => { L.DomEvent.stop(e); if (viewer) gotoImage(img.id, latlng); });
          m.addTo(pinLayer);
        }
        status(images.length ? `Pins: ${images.length}` : "No images in view for this user.");
      } catch (e) { console.error(e); status("Error loading pins."); }
    }

    map.on('moveend', () => { if (SHOW_PINS) { clearTimeout(window._pt); window._pt = setTimeout(drawPinsForView, 300); } });
    map.on('click', async (e) => {
      if (!TOKEN) { status("Add ?token=..."); return; }
      try {
        status("Finding image near click…");
        const img = await findImageNear({ lat: e.latlng.lat, lng: e.latlng.lng });
        if (img) { await gotoImage(img.id, [e.latlng.lat, e.latlng.lng]); status(""); }
        else status("No image found there.");
      } catch (err) { console.error(err); status("Error searching."); }
    });

    // -------- Compass reader (DOM-based) --------
    let viewer, navLock = 0;
    let compassEl = null, compassOffset = null; // offset so compass rotation -> camera bearing

    // Find the compass element inside Mapillary Viewer
    function findCompassEl() {
      const host = document.getElementById('mly');
      if (!host) return null;
      // Heuristic: any element whose class/title/aria mentions "compass"
      const nodes = host.querySelectorAll('*');
      for (const el of nodes) {
        const s = (el.className?.toString()||'') + ' ' + (el.getAttribute('aria-label')||'') + ' ' + (el.getAttribute('title')||'');
        if (/compass/i.test(s)) return el;
      }
      return null;
    }

    // Parse CSS transform -> rotation degrees (0..360)
    function getRotationDeg(el) {
      if (!el) return null;
      const styles = [el, el.firstElementChild].map(n => n ? getComputedStyle(n).transform : 'none');
      for (const t of styles) {
        if (!t || t === 'none') continue;
        // matrix(a,b,c,d,tx,ty)
        const m2 = t.match(/^matrix\(([-0-9., e]+)\)$/);
        if (m2) {
          const [a,b] = m2[1].split(',').map(parseFloat);
          const deg = Math.atan2(b, a) * 180/Math.PI;
          return (deg + 360) % 360;
        }
        // matrix3d(m11, m12, m13, ...)
        const m3 = t.match(/^matrix3d\(([-0-9., e]+)\)$/);
        if (m3) {
          const parts = m3[1].split(',').map(parseFloat);
          const a = parts[0], b = parts[1]; // m11, m12
          const deg = Math.atan2(b, a) * 180/Math.PI;
          return (deg + 360) % 360;
        }
      }
      return null;
    }

    // Calibrate: compare current compass rotation to true bearing from API
    async function calibrateBearing(imageId) {
      try {
        const url = new URL(`https://graph.mapillary.com/${imageId}`);
        url.searchParams.set("fields","computed_geometry,computed_compass_angle");
        const res = await fetch(url, { headers:{ Authorization:`OAuth ${TOKEN}` }});
        if (!res.ok) return;
        const j = await res.json();
        const coords = j?.computed_geometry?.coordinates;
        const bearing = j?.computed_compass_angle;
        if (coords?.length === 2) {
          const latlng = [coords[1], coords[0]];
          marker.setLatLng(latlng);
          if (VIEW !== 'image') map.setView(latlng, map.getZoom(), { animate:true });
        }
        if (typeof bearing === 'number') {
          // wait until the compass DOM exists & has a rotation
          if (!compassEl) compassEl = findCompassEl();
          let rot = getRotationDeg(compassEl);
          let tries = 0;
          while ((rot == null || isNaN(rot)) && tries < 20) {
            await new Promise(r => setTimeout(r, 100));
            if (!compassEl) compassEl = findCompassEl();
            rot = getRotationDeg(compassEl);
            tries++;
          }
          if (rot != null) {
            // We want: cameraBearing (from API) == compassOffset + rot  (mod 360)
            compassOffset = ((bearing - rot) % 360 + 360) % 360;
            // draw initial wedge
            const latlng = marker.getLatLng();
            drawOrientation(latlng.lat, latlng.lng, (compassOffset + rot) % 360, FOV_DEG_DEFAULT, 50);
            dbg(`calibrated\napi=${bearing.toFixed(1)}°\nrot=${rot.toFixed(1)}°\noffset=${compassOffset.toFixed(1)}°`);
          }
        }
      } catch {}
    }

    // Poll the compass rotation and update the wedge
    function startCompassWatcher() {
      setInterval(() => {
        if (!compassEl) compassEl = findCompassEl();
        const rot = getRotationDeg(compassEl);
        if (rot == null || compassOffset == null) return;
        const bearing = (compassOffset + rot) % 360;    // camera facing
        const pos = marker.getLatLng();
        drawOrientation(pos.lat, pos.lng, bearing, FOV_DEG_DEFAULT, 50);
        dbg(`live compass\nrot=${rot.toFixed(1)}°\nbearing=${bearing.toFixed(1)}°\noffset=${compassOffset.toFixed(1)}°`);
      }, 120); // ~8 fps, adjust as you like
    }

    // Navigation helper
    async function gotoImage(id, latlngHint) {
      const my = ++navLock;
      try { await viewer.setFilter(["all"]); } catch {}
      try {
        await viewer.moveTo(id);
        if (latlngHint) {
          marker.setLatLng([latlngHint[0], latlngHint[1]]);
          if (VIEW !== 'image') map.setView(latlngHint, map.getZoom(), { animate:true });
        }
        // re-calibrate after jumps (compass rotation may change abruptly)
        calibrateBearing(id);
      } finally {
        if (navLock === my) navLock = 0;
      }
    }

    (async function init(){
      if (!TOKEN) { status("Add ?token=YOUR_TOKEN"); return; }
      const M = window.Mapillary || window.mapillary || window.mapillaryjs;
      const ViewerCtor = M && M.Viewer;
      if (!ViewerCtor) { status("Mapillary library failed to load."); return; }

      viewer = new ViewerCtor({ container:"mly", accessToken:TOKEN });
      try { viewer.setFieldOfView(FOV_DEG_DEFAULT); } catch {}

      status("Searching for a nearby image…");
      const start = await findImageNear({ lat: defaults.lat, lng: defaults.lng });
      if (!start) { status(`No imagery by "${defaults.username}" near start.`); return; }

      await gotoImage(start.id);
      status("");

      // Re-draw/map sync on image change (and recalibrate)
      try {
        viewer.on('image', (ev) => {
          const id = ev?.image?.id || ev?.imageId || ev?.id;
          if (id) calibrateBearing(id);
        });
      } catch {}

      // Initial calibration & start compass watcher
      calibrateBearing(start.id);
      startCompassWatcher();

      if (SHOW_PINS) drawPinsForView();
    })();
  </script>
</body>
</html>
