<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>MapillaryJS – sticky wedge + marker follows viewer (rotSign)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- MapillaryJS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.css" />
  <script src="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.min.js"></script>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #wrap { height: 100vh; width: 100%; }
    #mly, #map { height: 100%; width: 100%; }
    #msg { position: absolute; top: 8px; left: 8px; z-index: 1000;
           background: rgba(0,0,0,.6); color: #fff; padding: 6px 10px; border-radius: 6px;
           font: 13px/1.4 system-ui, sans-serif; }
    #dbg { position: absolute; top: 8px; right: 8px; z-index: 1000;
           background: rgba(20,20,20,.72); color: #9ef; padding: 6px 10px; border-radius: 6px;
           font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; display:none; }
    .image-only { display:block; position:relative; }
    .image-only #map { display:none; }
    .map-only { display:block; }
    .map-only #mly { display:none; }
    .split { display:grid; grid-template-columns:1fr 1fr; }
    .split #mly, .split #map { display:block; }
  </style>
</head>
<body>
  <div id="wrap" class="image-only">
    <div id="mly" aria-label="Mapillary viewer"></div>
    <div id="map" aria-label="Map"></div>
    <div id="msg"></div>
    <pre id="dbg"></pre>
  </div>

  <script>
    // ------------------ Query/options ------------------
    const qs = new URLSearchParams(location.search);

    // Hard-coded token/opts for your demo
    const TOKEN = "MLY%7C24462366120070331%7C7b445698e786aaa212354b607653e542";
    const defaults = {
      lat: Number(30.138307),
      lng: Number(-91.965153),
      z:   Number(16),
      username: "HKocen"
    };

    const VIEW          = "split";     // image | map | split
    const SHOW_PINS     = "all";       // truthy => show
    const FOV_DEG       = Number(60);
    const DEBUG         = qs.get("debug") === "1";
    const MAX_PINS      = Number(2000);
    const START_BEARING = ((Number(qs.get("bearing")) || 0) + 360) % 360;
    const FOLLOW_MAP    = (qs.get("follow") ?? "1") !== "0";

    // +1 => wedge follows north arrow; -1 => wedge follows camera yaw (opposite of north arrow)
    const ROT_SIGN = (-1);

    // Only start on an image if within this distance (meters)
    const MAX_START_METERS = Number(qs.get("maxStartMeters") ?? 250);

    // Aim to open on an image whose compass is closest to this bearing (deg). 0 = North.
    const BEARING_TARGET = Number(qs.get("bearingTarget") ?? 0);

    const status = (t)=>{ document.getElementById('msg').textContent = t || ""; };
    const dbg    = (t)=>{ const el=document.getElementById('dbg'); if (DEBUG){ el.style.display='block'; el.textContent=t; } };

    // ------------------ Layout ------------------
    const wrap = document.getElementById('wrap');
    wrap.className = VIEW === 'split' ? 'split' : (VIEW === 'map' ? 'map-only' : 'image-only');

    const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
    const nextFrame = ()=>new Promise(r=>requestAnimationFrame(()=>requestAnimationFrame(r)));
    function zoomToMeters(z){ return 500000 / Math.pow(2, z); }

    // ------------------ Leaflet map ------------------
    const map = L.map('map', { zoomControl:true, attributionControl:true });
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
    const startLatLng = [defaults.lat, defaults.lng];

    // Slightly more zoomed out than your previous 16 → use 14
    const initialZoom = Math.max(0, (defaults.z || 16) - 2);
    map.setView(startLatLng, initialZoom);

    const marker = L.marker(startLatLng, { draggable:false }).addTo(map);
    const pinLayer = L.layerGroup().addTo(map);
    const orientationLayer = L.layerGroup().addTo(map);

    const defaultPinStyle = {
      radius: 4, color: '#1b5e20', weight: 2, opacity: 1,
      fillColor: '#2ecc71', fillOpacity: 0.9, className: 'pin'
    };

    // === HIGHLIGHT CHANGES ===
    const selectedPinStyle = {
      radius: 8, color: '#e53935', weight: 3, opacity: 1,
      fillColor: '#ffcdd2', fillOpacity: 1.0, className: 'pin-selected'
    };
    let pinsById = new Map();
    let selectedPin = null;

    function styleDefault(layer){ try{ layer.setStyle(defaultPinStyle); }catch{} }
    function styleSelected(layer){ try{ layer.setStyle(selectedPinStyle); layer.bringToFront(); }catch{} }

    function selectPinById(imageId){
      const lyr = pinsById.get(imageId);
      if(!lyr) return;
      if(selectedPin && selectedPin !== lyr) styleDefault(selectedPin);
      styleSelected(lyr);
      selectedPin = lyr;
    }
    // === END HIGHLIGHT CHANGES ===

    // ------------------ Helpers ------------------
    function bboxFromMap(m){ const b=m.getBounds(), sw=b.getSouthWest(), ne=b.getNorthEast(); return [sw.lng, sw.lat, ne.lng, ne.lat]; }
    function destPoint(lat,lng,bearingDeg,meters){
      const R=6371000, br=bearingDeg*Math.PI/180;
      const φ1=lat*Math.PI/180, λ1=lng*Math.PI/180, δ=meters/R;
      const φ2=Math.asin(Math.sin(φ1)*Math.cos(δ)+Math.cos(φ1)*Math.sin(δ)*Math.cos(br));
      const λ2=λ1+Math.atan2(Math.sin(br)*Math.sin(δ)*Math.cos(φ1), Math.cos(δ)-Math.sin(φ1)*Math.sin(φ2));
      return [φ2*180/Math.PI, ((λ2*180/Math.PI+540)%360)-180];
    }
    function drawOrientation(lat,lng,bearingDeg,fovDeg=FOV_DEG,length=50){
      orientationLayer.clearLayers();
      if(typeof bearingDeg!=='number') return;
      const left=bearingDeg-fovDeg/2, right=bearingDeg+fovDeg/2;
      const tip=destPoint(lat,lng,bearingDeg,length);
      const pLeft=destPoint(lat,lng,left,length);
      const pRight=destPoint(lat,lng,right,length);
      L.polygon([[lat,lng],pLeft,pRight],{color:'#1976d2',weight:1,fillColor:'#1976d2',fillOpacity:.18}).addTo(orientationLayer);
      L.polyline([[lat,lng],tip],{color:'#1976d2',weight:2,opacity:.9}).addTo(orientationLayer);
    }

    // Distance helpers
    function metersToDeg(lat, m){
      const dLat = m / 111320;
      const dLng = m / (111320 * Math.cos(lat * Math.PI/180) || 1e-6);
      return { dLat, dLng };
    }
    function haversineMeters(a, b){
      const R=6371000, toRad=Math.PI/180;
      const dLat=(b[0]-a[0])*toRad, dLng=(b[1]-a[1])*toRad;
      const s1=Math.sin(dLat/2), s2=Math.sin(dLng/2);
      const c1=Math.cos(a[0]*toRad)*Math.cos(b[0]*toRad);
      return 2*R*Math.asin(Math.sqrt(s1*s1 + c1*s2*s2));
    }
    function angDiffDeg(a, b){
      return Math.abs(((a - b + 540) % 360) - 180); // 0..180
    }

    // ------------------ Graph API (pins + image coords) ------------------
    // Find nearest image ONLY within a bbox; among candidates, prefer compass near BEARING_TARGET
    async function findImageNearWithinMeters({lat, lng, meters=MAX_START_METERS, cap=80}){
      const { dLat, dLng } = metersToDeg(lat, meters);
      const bbox = [lng - dLng, lat - dLat, lng + dLng, lat + dLat]; // [minX,minY,maxX,maxY]

      const url = new URL("https://graph.mapillary.com/images");
      url.searchParams.set("fields", "id,computed_geometry,computed_compass_angle");
      url.searchParams.set("bbox", bbox.join(","));
      url.searchParams.set("limit", String(cap));
      if (defaults.username) url.searchParams.set("creator_username", defaults.username);

      const res = await fetch(url, { headers: { Authorization: `OAuth ${TOKEN}` }});
      if (!res.ok) throw new Error(`API ${res.status}`);
      const j = await res.json();
      const arr = Array.isArray(j?.data) ? j.data : [];

      let best = null;
      let bestKey = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]; // [distance, angularDiff]
      for (const img of arr){
        const c = img?.computed_geometry?.coordinates;
        if (!c) continue;
        const latlng = [c[1], c[0]];
        const d = haversineMeters([lat, lng], latlng);
        const compass = typeof img?.computed_compass_angle === "number" ? img.computed_compass_angle : null;
        const ad = compass == null ? 180 : angDiffDeg(compass, BEARING_TARGET);
        const key = [d, ad];
        if (key[0] < bestKey[0] || (key[0] === bestKey[0] && key[1] < bestKey[1])){
          best = { id: img.id, latlng, d, compass };
          bestKey = key;
        }
      }
      return best; // null if none in range
    }

    async function getImageLatLng(imageId){
      const u=new URL(`https://graph.mapillary.com/${imageId}`);
      u.searchParams.set("fields","computed_geometry");
      const res=await fetch(u,{headers:{Authorization:`OAuth ${TOKEN}`}}); if(!res.ok) return null;
      const j=await res.json();
      const c=j?.computed_geometry?.coordinates;
      return Array.isArray(c) && c.length===2 ? [c[1], c[0]] : null;
    }
    async function setMarkerToImage(imageId){
      const latlng = await getImageLatLng(imageId);
      if(!latlng) return;
      marker.setLatLng(latlng);
      if(FOLLOW_MAP && VIEW!=='image'){
        map.setView(latlng, map.getZoom(), { animate:true });
      }
    }

    async function fetchImagesInBbox({bbox, cap=MAX_PINS}){
      const PAGE=2000; let out=[];
      let url=new URL("https://graph.mapillary.com/images");
      url.searchParams.set("fields","id,computed_geometry");
      url.searchParams.set("bbox", bbox.join(","));
      url.searchParams.set("limit", String(Math.min(PAGE, cap)));
      if(defaults.username) url.searchParams.set("creator_username", defaults.username);
      while(url && out.length<cap){
        const res=await fetch(url,{headers:{Authorization:`OAuth ${TOKEN}`}}); if(!res.ok) throw new Error(`API ${res.status}`);
        const j=await res.json(); if(Array.isArray(j.data)) out.push(...j.data);
        const next=j?.paging?.next; if(!next || out.length>=cap) break;
        url=new URL(next); url.searchParams.set("limit", String(Math.min(PAGE, cap - out.length)));
      }
      return out.slice(0, cap);
    }

    async function drawPinsForView(){
      if(!TOKEN || !SHOW_PINS) return;
      status("Loading user pins in view…");
      try{
        const images=await fetchImagesInBbox({bbox:bboxFromMap(map)});
        pinLayer.clearLayers();
        pinsById = new Map();
        selectedPin = null;

        for(const img of images){
          const c=img?.computed_geometry?.coordinates; if(!c) continue;
          const latlng=[c[1],c[0]];
          const pin = L.circleMarker(latlng, defaultPinStyle)
            .on('click', (e)=>{
              L.DomEvent.stop(e);
              selectPinById(img.id);
              if(viewer) gotoImage(img.id, latlng);
            })
            .addTo(pinLayer);
          pinsById.set(img.id, pin);
        }
        status(`Pins: ${images.length}`);
      }catch(e){ console.error(e); status("Error loading pins."); }
    }
    let pinTimer=null;
    map.on('moveend', ()=>{ if(!SHOW_PINS) return; clearTimeout(pinTimer); pinTimer=setTimeout(drawPinsForView,350); });
    map.on('click', async (e)=>{
      if(!TOKEN){ status("Add ?token=..."); return; }
      try{
        status("Finding image near click…");
        const startClick = await findImageNearWithinMeters({ lat:e.latlng.lat, lng:e.latlng.lng, meters: MAX_START_METERS });
        if(startClick){
          selectPinById(startClick.id);
          await gotoImage(startClick.id, [e.latlng.lat, e.latlng.lng]);
          status("");
        }
        else status("No image found there.");
      }catch(err){ console.error(err); status("Error searching."); }
    });

    // ------------------ Compass reading (DOM) ------------------
    function getRotationDeg(rootEl){
      if(!rootEl) return null;
      const q=[rootEl]; let depth=0, nextBreak=1, count=0, maxDepth=3;
      while(q.length && depth<=maxDepth){
        const el=q.shift();
        const t=getComputedStyle(el).transform || el.style?.transform || '';
        const deg=parseTransformToDeg(t); if(deg!=null) return (deg+360)%360;
        for(const ch of el.children||[]) q.push(ch);
        count++; if(count===nextBreak){ depth++; nextBreak=q.length+count; }
      }
      return null;
      function parseTransformToDeg(tr){
        if(!tr || tr==='none') return null;
        const r=/rotate[Z]?\(\s*([-+0-9.]+)\s*(deg|rad)\s*\)/i.exec(tr);
        if(r){ const v=parseFloat(r[1]); return r[2].toLowerCase()==='rad'? v*180/Math.PI : v; }
        const m2=/^matrix\(\s*([-+0-9eE.,\s]+)\)$/.exec(tr);
        if(m2){ const [a,b]=m2[1].split(',').map(x=>parseFloat(x)); return Math.atan2(b,a)*180/Math.PI; }
        const m3=/^matrix3d\(\s*([-+0-9eE.,\s]+)\)$/.exec(tr);
        if(m3){ const p=m3[1].split(',').map(x=>parseFloat(x)); return Math.atan2(p[1],p[0])*180/Math.PI; }
        return null;
      }
    }
    function getCompassRotation(){
      const host=document.getElementById('mly');
      const trySel=(sel,src)=>{ const el=host && host.querySelector(sel); const deg=getRotationDeg(el);
        return deg!=null ? {rot:((deg%360)+360)%360, src} : null; };
      return (
        trySel('.mapillary-bearing-indicator-background','bg') ||
        trySel('.mapillary-bearing-indicator-background-arrow','bg-arrow') ||
        trySel('.mapillary-bearing-north-container','north') ||
        trySel('[class*="bearing"]','fallback') ||
        {rot:null, src:'none'}
      );
    }
    async function readStableCompassRotation(maxWaitMs=3500){
      const t0=performance.now(); let last=null, stable=0; let result={rot:null,src:'none'};
      while(performance.now()-t0<maxWaitMs){
        const r=getCompassRotation();
        if(r.rot!=null){
          const diff= last==null ? 999 : Math.abs(((r.rot-last+540)%360)-180);
          if(diff<0.5){ if(++stable>=3) return r; }
          else { stable=0; last=r.rot; result=r; }
        }
        await sleep(100);
      }
      return result;
    }

    // ------------------ Sticky wedge logic ------------------
    let viewer, navLock=0;
    let compassOffset=0;              // wedgeBearing = (compassOffset + ROT_SIGN*rot) % 360
    let stickyBearing=START_BEARING;  // keep angle across photos
    let suspendWatcher=false;         // pause live updates during anchoring

    async function reanchorToSticky(){
      suspendWatcher = true;
      await nextFrame();                         // ensure new image is mounted
      const {rot, src} = await readStableCompassRotation();
      if(rot!=null){
        // Apply ROT_SIGN so we anchor against the desired rotation direction
        compassOffset = ((stickyBearing - ROT_SIGN * rot) % 360 + 360) % 360;
        const p=marker.getLatLng();
        drawOrientation(p.lat, p.lng, stickyBearing, FOV_DEG, 50);
        if (DEBUG) dbg(`reanchor\nrot=${rot.toFixed(1)}°\nsticky=${stickyBearing.toFixed(1)}°\noffset=${compassOffset.toFixed(1)}°\nsrc=${src}\nrotSign=${ROT_SIGN}`);
      }
      suspendWatcher = false;
    }

    function startCompassWatcher(){
      setInterval(()=>{
        if(suspendWatcher) return;
        const {rot, src} = getCompassRotation();
        if(rot==null) return;
        const bearing = (compassOffset + ROT_SIGN * rot) % 360;
        stickyBearing = bearing; // remember for next photo
        const pos=marker.getLatLng();
        drawOrientation(pos.lat, pos.lng, bearing, FOV_DEG, 50);
        if (DEBUG) dbg(`live\nrot=${rot.toFixed(1)}°\nbearing=${bearing.toFixed(1)}°\noffset=${compassOffset.toFixed(1)}°\nsrc=${src}\nrotSign=${ROT_SIGN}`);
      }, 120);
    }

    // ------------------ Navigation ------------------
    async function gotoImage(id, latlngHint){
      const my=++navLock;
      try{ await viewer.setFilter(["all"]); }catch{}
      try{
        suspendWatcher = true;
        await viewer.moveTo(id);

        if (SHOW_PINS) selectPinById(id);

        if(latlngHint){
          marker.setLatLng([latlngHint[0], latlngHint[1]]);
          if(FOLLOW_MAP && VIEW!=='image') map.setView(latlngHint, map.getZoom(), {animate:true});
        }
      } finally {
        if(navLock===my) navLock=0;
      }
    }

    // ------------------ Init ------------------
    (async function init(){
      if(!TOKEN){ status("Add ?token=YOUR_TOKEN"); return; }
      const M=window.Mapillary || window.mapillary || window.mapillaryjs;
      const ViewerCtor=M && M.Viewer;
      if(!ViewerCtor){ status("Mapillary library failed to load."); return; }

      viewer=new ViewerCtor({ container:"mly", accessToken:TOKEN });
      try{ viewer.setFieldOfView(FOV_DEG); }catch{}

      status("Searching for a nearby image…");
      const start = await findImageNearWithinMeters({
        lat: defaults.lat,
        lng: defaults.lng,
        meters: MAX_START_METERS
      });

      if (!start){
        status(`No imagery within ${MAX_START_METERS} m${defaults.username ? ` for "${defaults.username}"` : ""}. Staying at start.`);
        if (SHOW_PINS) drawPinsForView();
        startCompassWatcher();
        return;
      }

      // On image change: move marker to that image, then reanchor so the angle sticks
      try {
        viewer.on('image', async (ev)=>{
          const id=ev?.image?.id || ev?.imageId || ev?.id;
          if(!id) return;
          const latlng = await getImageLatLng(id);
          if(latlng){
            marker.setLatLng(latlng);
            if(FOLLOW_MAP && VIEW!=='image') map.setView(latlng, map.getZoom(), {animate:true});
          }
          if (SHOW_PINS) selectPinById(id);
          await reanchorToSticky();
        });
      } catch {}

      // Move to the start image that is actually within range (and closest to north)
      await gotoImage(start.id, start.latlng);

      // initial marker + anchor (redundant safe-guard)
      const latlng0 = await getImageLatLng(start.id);
      if(latlng0){
        marker.setLatLng(latlng0);
        if(FOLLOW_MAP && VIEW!=='image') map.setView(latlng0, map.getZoom(), {animate:true});
      }
      if (SHOW_PINS) selectPinById(start.id);

      await reanchorToSticky();
      status("");

      startCompassWatcher();
      if(SHOW_PINS) drawPinsForView();
    })();
  </script>
</body>
</html>
