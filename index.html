<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mapillary Split (Viewer + Map)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- MapillaryJS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.css" />
  <script src="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.min.js"></script>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #wrap { height: 100vh; width: 100%; display: grid; grid-template-columns: 1fr 1fr; }
    #mly, #map { height: 100%; width: 100%; }
    /* tiny helper badge */
    #badge { position: absolute; top: 8px; left: 8px; z-index: 500; background: rgba(255,255,255,.9);
             padding: 6px 8px; border-radius: 8px; font: 12px/1.2 system-ui, sans-serif; }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="mly"></div>
    <div id="map"></div>
  </div>
  <div id="badge">User: <b>HKocen</b> â€¢ Start image: <b>744575191439794</b></div>

  <script>
    // ==== CONFIG ====
    const ACCESS_TOKEN = "MLY|24840280672250420|6fc0e204403850a11ccc043866f1b01d";
    const START_IMAGE_ID = "744575191439794";
    const USERNAME_FILTER = "HKocen";
    const GRAPH_BASE = "https://graph.mapillary.com";

    // ==== MAPILLARY VIEWER ====
    const viewer = new mapillary.Viewer({
      container: "mly",
      accessToken: ACCESS_TOKEN,
      imageId: START_IMAGE_ID,
      component: { cover: true, direction: true, zoom: true, attribution: true }
    });

    // ==== LEAFLET MAP ====
    const map = L.map("map", { zoomControl: true });
    const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19, attribution: "&copy; OpenStreetMap"
    }).addTo(map);

    const pinsLayer = L.geoJSON(null, {
      pointToLayer: (feat, latlng) => L.circleMarker(latlng, { radius: 6, weight: 2 })
    }).addTo(map);

    const cursor = L.circleMarker([0,0], { radius: 8, weight: 3 }).addTo(map);

    // ==== HELPERS ====
    async function fetchJSON(url) {
      const r = await fetch(url);
      if (!r.ok) throw new Error(await r.text());
      return r.json();
    }

    async function getImagePosition(imageId) {
      // Get coordinates for a specific image
      const fields = "id,computed_geometry";
      const url = `${GRAPH_BASE}/images/${imageId}?fields=${fields}&access_token=${encodeURIComponent(ACCESS_TOKEN)}`;
      const j = await fetchJSON(url);
      const coords = j.computed_geometry && j.computed_geometry.coordinates;
      if (!coords) throw new Error("No geometry for image " + imageId);
      // Mapillary returns [lng, lat]
      return [coords[1], coords[0]];
    }

    async function loadPinsForUserInBbox(bbox) {
      // bbox: [west,south,east,north]
      // Only fetch pins for the provided username within current map view
      const fields = "id,computed_geometry";
      const params = new URLSearchParams({
        fields,
        limit: "500",
        // username filter (Mapillary Graph supports 'usernames=' for public usernames)
        usernames: USERNAME_FILTER,
        bbox: bbox.join(","),
        access_token: ACCESS_TOKEN
      });
      const url = `${GRAPH_BASE}/images?${params.toString()}`;
      const j = await fetchJSON(url);

      const features = (j.data || [])
        .filter(d => d.computed_geometry && d.computed_geometry.coordinates)
        .map(d => ({
          type: "Feature",
          geometry: { type: "Point", coordinates: d.computed_geometry.coordinates },
          properties: { id: d.id }
        }));

      pinsLayer.clearLayers();
      pinsLayer.addData({ type: "FeatureCollection", features });

      // Click to jump the viewer to that image
      pinsLayer.eachLayer(layer => {
        const imageId = layer.feature.properties.id;
        layer.on("click", () => viewer.moveTo(imageId));
        layer.bindTooltip(`Image ${imageId}`);
      });
    }

    function currentMapBBox() {
      const b = map.getBounds();
      const west = b.getWest(), south = b.getSouth(), east = b.getEast(), north = b.getNorth();
      return [west, south, east, north];
    }

    // ==== SYNC: VIEWER -> MAP ====
    async function onViewerImageChange(e) {
      try {
        const imageId = e.imageId;
        const latlng = await getImagePosition(imageId);
        cursor.setLatLng(latlng);
        // Only recenter if cursor is outside map bounds (reduces jumpiness)
        if (!map.getBounds().pad(-0.2).contains(latlng)) {
          map.setView(latlng, Math.max(map.getZoom(), 16));
        }
      } catch (err) {
        // silently ignore for embed
        console.warn(err);
      }
    }

    viewer.on("image", onViewerImageChange);

    // ==== SYNC: MAP -> PINS (and initial boot) ====
    let pinLoadTimeout = null;
    function schedulePinLoad() {
      clearTimeout(pinLoadTimeout);
      pinLoadTimeout = setTimeout(() => {
        const bbox = currentMapBBox();
        loadPinsForUserInBbox(bbox).catch(console.warn);
      }, 300);
    }
    map.on("moveend", schedulePinLoad);

    // ==== INIT ====
    (async () => {
      try {
        const startLatLng = await getImagePosition(START_IMAGE_ID);
        map.setView(startLatLng, 17);
        cursor.setLatLng(startLatLng);
        schedulePinLoad();
      } catch (err) {
        console.error(err);
        // fallback: center USA-ish if start image lookup fails
        map.setView([37.8, -96], 4);
        schedulePinLoad();
      }
    })();
  </script>
</body>
</html>
