<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>MapillaryJS – image + map (stable pin navigation)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- MapillaryJS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.css" />
  <script src="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.min.js"></script>

  <!-- Leaflet (OSM tiles) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #wrap { height: 100vh; width: 100%; }
    #mly, #map { height: 100%; width: 100%; }
    #msg { position: absolute; top: 8px; left: 8px; z-index: 1000;
           background: rgba(0,0,0,0.6); color: #fff; padding: 6px 10px; border-radius: 6px;
           font: 13px/1.4 system-ui, sans-serif; }
    .image-only { display: block; position: relative; }
    .image-only #map { display: none; }
    .map-only   { display: block; }
    .map-only   #mly { display: none; }
    .split      { display: grid; grid-template-columns: 1fr 1fr; }
    .split #mly, .split #map { display: block; }
    .pin { cursor: pointer; }
  </style>
</head>
<body>
  <div id="wrap" class="image-only">
    <div id="mly" aria-label="Mapillary viewer"></div>
    <div id="map" aria-label="Map"></div>
    <div id="msg"></div>
  </div>

  <script>
    const qs = new URLSearchParams(location.search);
    const TOKEN = qs.get("token") || "";
    const defaults = {
      lat: Number(qs.get("lat") ?? 30.145619851543174),
      lng: Number(qs.get("lng") ?? -91.87748325231672),
      z:   Number(qs.get("z")   ?? 11.4),
      username: (qs.get("username") || "HKocen").trim()
    };
    const VIEW = (qs.get("view") || "image").toLowerCase();      // image | map | split
    const SHOW_PINS = (qs.get("pins") || "").toLowerCase() === "all";
    const status = (t) => { document.getElementById('msg').textContent = t || ""; };

    // Layout
    const wrap = document.getElementById('wrap');
    wrap.className = VIEW === 'split' ? 'split' : (VIEW === 'map' ? 'map-only' : 'image-only');

    const zoomToMeters = (z) => 500000 / Math.pow(2, z);

    // --- Leaflet map ---
    const map = L.map('map', { zoomControl: true, attributionControl: true });
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
    const startLatLng = [defaults.lat, defaults.lng];
    map.setView(startLatLng, 13);

    const marker = L.marker(startLatLng, { draggable: false }).addTo(map);
    const pinLayer = L.layerGroup().addTo(map);

    // --- Mapillary helpers ---
    function bboxFromMap(m) {
      const b = m.getBounds();
      const sw = b.getSouthWest(), ne = b.getNorthEast();
      return [sw.lng, sw.lat, ne.lng, ne.lat]; // minLon,minLat,maxLon,maxLat
    }

    async function findImageNear({lat, lng}) {
      const url = new URL("https://graph.mapillary.com/images");
      url.searchParams.set("fields", "id,computed_geometry");
      url.searchParams.set("closeto", `${lng},${lat}`);
      url.searchParams.set("radius", Math.max(25, Math.round(zoomToMeters(defaults.z))));
      url.searchParams.set("limit", "1");
      if (defaults.username) url.searchParams.set("creator_username", defaults.username);
      const res = await fetch(url, { headers: { Authorization: `OAuth ${TOKEN}` }});
      if (!res.ok) throw new Error(`API error ${res.status}`);
      const j = await res.json();
      return j?.data?.[0] ?? null;
    }

    async function fetchImagesInBbox({bbox, cap=3000}) {
      let url = new URL("https://graph.mapillary.com/images");
      url.searchParams.set("fields", "id,computed_geometry");
      url.searchParams.set("bbox", bbox.join(","));
      url.searchParams.set("limit", "500");
      if (defaults.username) url.searchParams.set("creator_username", defaults.username);

      const out = [];
      while (url && out.length < cap) {
        const res = await fetch(url, { headers: { Authorization: `OAuth ${TOKEN}` }});
        if (!res.ok) throw new Error(`API error ${res.status}`);
        const j = await res.json();
        if (Array.isArray(j.data)) out.push(...j.data);
        const next = j?.paging?.next;
        if (!next) break;
        url = new URL(next);
      }
      return out;
    }

    async function drawPinsForView() {
      if (!TOKEN || !SHOW_PINS) return;
      status("Loading user pins in view…");
      try {
        const images = await fetchImagesInBbox({ bbox: bboxFromMap(map) });
        pinLayer.clearLayers();
        for (const img of images) {
          const coords = img?.computed_geometry?.coordinates; // [lon, lat]
          if (!coords) continue;
          const latlng = [coords[1], coords[0]];
          const c = L.circleMarker(latlng, {
            radius: 3, color: '#1b5e20', weight: 1, opacity: 0.9, fillColor: '#2ecc71', fillOpacity: 0.6, className: 'pin'
          });

          // Stop this click from bubbling to the map's click handler
          c.on('click', (e) => {
            L.DomEvent.stop(e); // prevents map.click from firing
            if (viewer) gotoImage(img.id, latlng);
          });

          c.addTo(pinLayer);
        }
        status(images.length ? `Pins: ${images.length}` : "No images in view for this user.");
      } catch (e) {
        console.error(e);
        status("Error loading pins.");
      }
    }

    // Debounced requery on pan/zoom
    let pinTimer = null;
    map.on('moveend', () => {
      if (!SHOW_PINS) return;
      clearTimeout(pinTimer);
      pinTimer = setTimeout(drawPinsForView, 350);
    });

    // Background map click => nearest image
    map.on('click', async (e) => {
      if (!TOKEN) { status("Add ?token=... to enable image navigation."); return; }
      try {
        status("Finding image near map click…");
        const img = await findImageNear({ lat: e.latlng.lat, lng: e.latlng.lng });
        if (img) { await gotoImage(img.id, [e.latlng.lat, e.latlng.lng]); status(""); }
        else { status("No image found near that point for this user."); }
      } catch (err) { console.error(err); status("Error searching for image near click."); }
    });

    // --- Mapillary viewer ---
    let viewer = null;
    let navLock = 0; // prevents click races

    // Clear filters and navigate to an image ID, with a short nav lock
    async function gotoImage(id, latlngHint) {
      const myLock = ++navLock;
      try { await viewer.setFilter(["all"]); } catch {}
      try {
        await viewer.moveTo(id);
        // move map marker immediately for responsiveness
        if (latlngHint) {
          marker.setLatLng([latlngHint[0], latlngHint[1]]);
          if (VIEW !== 'image') map.setView(latlngHint, map.getZoom(), { animate: true });
        }
      } finally {
        // only release if we're still the last navigation
        if (navLock === myLock) navLock = 0;
      }
    }

    (async function init(){
      if (!TOKEN) {
        status(SHOW_PINS ? "Add ?token=YOUR_TOKEN to enable navigation; pins will not load without a token."
                         : "Map only: add ?view=split (or image) and ?token=YOUR_TOKEN to enable the viewer.");
        return;
      }

      const M = window.Mapillary || window.mapillary || window.mapillaryjs;
      const ViewerCtor = M && M.Viewer;
      if (!ViewerCtor) { status("Mapillary library failed to load."); return; }

      viewer = new ViewerCtor({ container: "mly", accessToken: TOKEN });

      try {
        status("Searching for a nearby image…");
        const start = await findImageNear({ lat: defaults.lat, lng: defaults.lng });
        if (!start) { status(`No imagery by "${defaults.username}" near ${defaults.lat.toFixed(5)}, ${defaults.lng.toFixed(5)}.`); return; }

        await gotoImage(start.id);
        status("");

        viewer.setFieldOfView(45);

        // Sync map to current image (from viewer -> map)
        async function syncMap(imageId) {
          try {
            const url = new URL(`https://graph.mapillary.com/${imageId}`);
            url.searchParams.set("fields", "computed_geometry");
            const res = await fetch(url, { headers: { Authorization: `OAuth ${TOKEN}` }});
            if (!res.ok) return;
            const j = await res.json();
            const coords = j?.computed_geometry?.coordinates; // [lon, lat]
            if (coords && coords.length === 2) {
              const latlng = [coords[1], coords[0]];
              marker.setLatLng(latlng);
              if (VIEW !== 'image') map.setView(latlng, map.getZoom(), { animate: true });
            }
          } catch {}
        }

        try {
          viewer.on('image', (ev) => {
            // Ignore if a newer navigation is in flight
            if (navLock) return;
            const id = ev?.image?.id || ev?.imageId || ev?.id;
            if (id) syncMap(id);
          });
        } catch {
          setInterval(async () => {
            if (navLock) return;
            try { const id = (await viewer.getState?.())?.imageId; if (id) syncMap(id); } catch {}
          }, 1500);
        }

        if (SHOW_PINS) drawPinsForView();

      } catch (e) {
        console.error(e);
        status("Error: " + (e?.message || e));
      }
    })();
  </script>
</body>
</html>

