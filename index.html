<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mapillary viewer + map (split)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- MapillaryJS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.css" />
  <script src="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.min.js"></script>

  <!-- MapLibre GL (Mapbox GL compatible) -->
  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #app { position: relative; height: 100vh; width: 100%; }
  </style>
</head>
<body>
  <div id="app"></div>

  <script>
    // === Your config ===
    const MLY_ACCESS_TOKEN = "MLY|24840280672250420|6fc0e204403850a11ccc043866f1b01d";
    const START_IMAGE_ID   = "744575191439794";
    const START_CENTER     = { lng: -91.965153, lat: 30.138307 }; // approx start center

    // Use MapLibre via the mapboxgl alias so the code matches your sample
    window.mapboxgl = window.maplibregl;

    // Raster OSM style with maxzoom 19 (fix for “blank map at z18”)
    const OSM_RASTER_STYLE = {
      "version": 8,
      "name": "OSM Raster",
      "sources": {
        "osm": {
          "type": "raster",
          "tiles": ["https://tile.openstreetmap.org/{z}/{x}/{y}.png"],
          "tileSize": 256,
          "minzoom": 0,
          "maxzoom": 19,
          "attribution": "© OpenStreetMap contributors"
        }
      },
      "layers": [
        { "id": "background", "type": "background", "paint": { "background-color": "#e6f2d8" } },
        { "id": "osm-tiles",  "type": "raster",     "source": "osm" }
      ]
    };

    // ===== Helpers to create split containers (viewer left, map right) =====
    function makeContainers(container) {
      const boundingRect = container.getBoundingClientRect();
      const height = `calc(100vh - ${boundingRect.top}px)`;

      const viewerContainer = document.createElement('div');
      viewerContainer.style.position = 'absolute';
      viewerContainer.style.left = '0';
      viewerContainer.style.top = '0';
      viewerContainer.style.height = height;
      viewerContainer.style.width = '61.8%';

      const mapContainer = document.createElement('div');
      mapContainer.style.position = 'absolute';
      mapContainer.style.right = '0';
      mapContainer.style.top = '0';
      mapContainer.style.height = height;
      mapContainer.style.width = 'calc(38.2% - 2px)';
      mapContainer.style.marginLeft = '2px';

      container.appendChild(viewerContainer);
      container.appendChild(mapContainer);

      return { viewer: viewerContainer, map: mapContainer };
    }

    function makeMapboxMarker(options) {
      const size = `${2 * options.radius}px`;
      const circle = document.createElement('div');
      circle.style.border = `3px solid ${options.color}`;
      circle.style.backgroundColor = 'rgba(255, 255, 255, 0.6)';
      circle.style.height = size;
      circle.style.borderRadius = '50%';
      circle.style.width = size;
      return new mapboxgl.Marker({ element: circle, rotationAlignment: 'map' });
    }

    const RAD2DEG = 180 / Math.PI;
    const DEG2RAD = Math.PI / 180;
    const rotateArc = (bearing) => `rotateZ(${bearing}deg)`;

    function makeArc(fovDeg) {
      const radius = 45, centerX = 50, centerY = 50;
      const fovRad = DEG2RAD * fovDeg;
      const arcStart = -Math.PI / 2 - fovRad / 2;
      const arcEnd   = arcStart + fovRad;

      const startX = centerX + radius * Math.cos(arcStart);
      const startY = centerY + radius * Math.sin(arcStart);
      const endX   = centerX + radius * Math.cos(arcEnd);
      const endY   = centerY + radius * Math.sin(arcEnd);

      const center = `M ${centerX} ${centerY}`;
      const line   = `L ${startX} ${startY}`;
      const arc    = `A ${radius} ${radius} 0 0 1 ${endX} ${endY}`;
      return `${center} ${line} ${arc} Z`;
    }

    function makeCamera(bearingDeg, fovDeg) {
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', makeArc(fovDeg));
      path.setAttribute('fill', 'yellow');
      path.setAttribute('fill-opacity', '0.5');
      path.setAttribute('stroke', 'black');
      path.setAttribute('stroke-width', '1');
      path.setAttribute('stroke-linejoin', 'round');

      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('viewBox', '0 0 100 100');
      svg.appendChild(path);
      svg.style.height = '100%';
      svg.style.width  = '100%';
      svg.style.transform = rotateArc(bearingDeg);

      const container = document.createElement('div');
      container.style.height = '200px';
      container.style.width  = '200px';
      container.appendChild(svg);
      return container;
    }

    // ===== App =====
    let viewer, map;

    async function init() {
      const app = document.getElementById('app');
      const containers = makeContainers(app);

      // Mapillary viewer
      const ViewerCtor = (window.mapillary && window.mapillary.Viewer) || window.Viewer;
      viewer = new ViewerCtor({
        accessToken: MLY_ACCESS_TOKEN,
        component: { cover: false },
        container: containers.viewer,
      });
      viewer.moveTo(START_IMAGE_ID).catch(err => console.warn(err));

      // Map (MapLibre) with embedded OSM raster style
      map = new mapboxgl.Map({
        container: containers.map,
        style: OSM_RASTER_STYLE,
        center: [START_CENTER.lng, START_CENTER.lat],
        zoom: 18,
        pitch: 45,
      });

      // Camera wedge + markers
      const camera = makeCamera(0, 90);
      const cameraMarker   = new mapboxgl.Marker({ element: camera, rotationAlignment: 'map' });
      const originalMarker = makeMapboxMarker({ radius: 14, color: '#f00' });
      const lngLatMarker   = makeMapboxMarker({ radius: 14, color: '#00f' });
      const positionMarker = makeMapboxMarker({ radius: 10, color: '#f0f' });

      const onImage = (image) => {
        const lngLat = [image.lngLat.lng, image.lngLat.lat];
        lngLatMarker.setLngLat(lngLat);
        if (!map.getBounds().contains(lngLat)) map.setCenter(lngLat);

        const originalPos = [image.originalLngLat.lng, image.originalLngLat.lat];
        originalMarker.setLngLat(originalPos);
      };

      const onFov = async () => {
        const viewerContainer = viewer.getContainer();
        const h = viewerContainer.offsetHeight;
        const w = viewerContainer.offsetWidth;
        const aspect = h === 0 ? 0 : w / h;

        const verticalFov   = DEG2RAD * (await viewer.getFieldOfView());
        const horizontalFov = RAD2DEG * Math.atan(aspect * Math.tan(0.5 * verticalFov)) * 2;

        const path = camera.querySelector('path');
        path.setAttribute('d', makeArc(horizontalFov));
      };

      const onPov = async () => {
        const pov = await viewer.getPointOfView();
        const svg = camera.querySelector('svg');
        svg.style.transform = rotateArc(pov.bearing);
      };

      const onPosition = async () => {
        const position = await viewer.getPosition();
        const pos = [position.lng, position.lat];
        positionMarker.setLngLat(pos);
        cameraMarker.setLngLat(pos);
      };

      viewer.on('load', async () => {
        const image = await viewer.getImage();
        onImage(image);

        await onFov();
        await onPov();
        await onPosition();

        lngLatMarker.addTo(map);
        originalMarker.addTo(map);
        positionMarker.addTo(map);
        cameraMarker.addTo(map);
      });

      viewer.on('image', (event) => onImage(event.image));
      viewer.on('position', onPosition);
      viewer.on('fov', onFov);
      window.addEventListener('resize', onFov);
      viewer.on('pov', onPov);
    }

    init();
  </script>
</body>
</html>
