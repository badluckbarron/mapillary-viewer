<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>MapillaryJS – image + map (live orientation + pins)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- MapillaryJS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.css" />
  <script src="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.min.js"></script>

  <!-- Leaflet (OSM tiles) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #wrap { height: 100vh; width: 100%; }
    #mly, #map { height: 100%; width: 100%; }
    #msg { position: absolute; top: 8px; left: 8px; z-index: 1000;
           background: rgba(0,0,0,0.6); color: #fff; padding: 6px 10px; border-radius: 6px;
           font: 13px/1.4 system-ui, sans-serif; }
    .image-only { display: block; position: relative; }
    .image-only #map { display: none; }
    .map-only   { display: block; }
    .map-only   #mly { display: none; }
    .split      { display: grid; grid-template-columns: 1fr 1fr; }
    .split #mly, .split #map { display: block; }
  </style>
</head>
<body>
  <div id="wrap" class="image-only">
    <div id="mly" aria-label="Mapillary viewer"></div>
    <div id="map" aria-label="Map"></div>
    <div id="msg"></div>
  </div>

  <script>
    const qs = new URLSearchParams(location.search);
    const TOKEN = qs.get("token") || "";
    const defaults = {
      lat: Number(qs.get("lat") ?? 30.147146),
      lng: Number(qs.get("lng") ?? -91.961231),
      z:   Number(qs.get("z")   ?? 12),
      username: (qs.get("username") || "HKocen").trim()
    };
    const VIEW = (qs.get("view") || "image").toLowerCase();      // image | map | split
    const SHOW_PINS = (qs.get("pins") || "").toLowerCase() === "all";
    const FOV_DEG_DEFAULT = Number(qs.get("fov") ?? 60);         // initial viewer FOV & wedge width
    let currentFovDeg = FOV_DEG_DEFAULT;                          // <-- live-synced FOV for wedge

    const status = (t) => { document.getElementById('msg').textContent = t || ""; };

    // Layout
    const wrap = document.getElementById('wrap');
    wrap.className = VIEW === 'split' ? 'split' : (VIEW === 'map' ? 'map-only' : 'image-only');

    function zoomToMeters(z) { return 500000 / Math.pow(2, z); }

    // --- Leaflet map ---
    const map = L.map('map', { zoomControl: true, attributionControl: true });
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
    const startLatLng = [defaults.lat, defaults.lng];
    map.setView(startLatLng, 13);

    const marker = L.marker(startLatLng, { draggable: false }).addTo(map);
    const pinLayer = L.layerGroup().addTo(map);
    const orientationLayer = L.layerGroup().addTo(map); // wedge + center line

    // Nice green pins
    const defaultPinStyle = {
      radius: 4,
      color: '#1b5e20',
      weight: 2,
      opacity: 1,
      fillColor: '#2ecc71',
      fillOpacity: 0.9,
      className: 'pin'
    };

    // --- Helpers ---
    function bboxFromMap(m) {
      const b = m.getBounds();
      const sw = b.getSouthWest(), ne = b.getNorthEast();
      return [sw.lng, sw.lat, ne.lng, ne.lat]; // minLon,minLat,maxLon,maxLat
    }

    // Geodesic destination from (lat,lng) given bearing (deg) and distance (m)
    function destPoint(lat, lng, bearingDeg, meters) {
      const R = 6371000; // m
      const br = bearingDeg * Math.PI / 180;
      const φ1 = lat * Math.PI / 180, λ1 = lng * Math.PI / 180, δ = meters / R;
      const φ2 = Math.asin(Math.sin(φ1) * Math.cos(δ) + Math.cos(φ1) * Math.sin(δ) * Math.cos(br));
      const λ2 = λ1 + Math.atan2(Math.sin(br) * Math.sin(δ) * Math.cos(φ1),
                                  Math.cos(δ) - Math.sin(φ1) * Math.sin(φ2));
      return [φ2 * 180 / Math.PI, ((λ2 * 180 / Math.PI + 540) % 360) - 180];
    }

    // Draw a wedge + center line from (lat,lng) toward bearingDeg with fovDeg width
    function drawOrientation(lat, lng, bearingDeg, fovDeg = currentFovDeg, length = 50) {
      orientationLayer.clearLayers();
      if (typeof bearingDeg !== 'number') return;
      const left = bearingDeg - fovDeg / 2;
      const right = bearingDeg + fovDeg / 2;
      const tip   = destPoint(lat, lng, bearingDeg, length);
      const pLeft = destPoint(lat, lng, left,    length);
      const pRight= destPoint(lat, lng, right,   length);
      L.polygon([[lat, lng], pLeft, pRight], {
        color: '#1976d2', weight: 1, fillColor: '#1976d2', fillOpacity: 0.18
      }).addTo(orientationLayer);
      L.polyline([[lat, lng], tip], { color: '#1976d2', weight: 2, opacity: 0.9 }).addTo(orientationLayer);
    }

    async function findImageNear({lat, lng}) {
      const url = new URL("https://graph.mapillary.com/images");
      url.searchParams.set("fields", "id,computed_geometry");
      url.searchParams.set("closeto", `${lng},${lat}`);
      url.searchParams.set("radius", Math.max(25, Math.round(zoomToMeters(defaults.z))));
      url.searchParams.set("limit", "1");
      if (defaults.username) url.searchParams.set("creator_username", defaults.username);
      const res = await fetch(url, { headers: { Authorization: `OAuth ${TOKEN}` }});
      if (!res.ok) throw new Error(`API error ${res.status}`);
      const j = await res.json();
      return j?.data?.[0] ?? null;
    }

    async function fetchImagesInBbox({bbox, cap=3000}) {
      let url = new URL("https://graph.mapillary.com/images");
      url.searchParams.set("fields", "id,computed_geometry");
      url.searchParams.set("bbox", bbox.join(","));
      url.searchParams.set("limit", "100");
      if (defaults.username) url.searchParams.set("creator_username", defaults.username);
      const out = [];
      while (url && out.length < cap) {
        const res = await fetch(url, { headers: { Authorization: `OAuth ${TOKEN}` }});
        if (!res.ok) throw new Error(`API error ${res.status}`);
        const j = await res.json();
        if (Array.isArray(j.data)) out.push(...j.data);
        const next = j?.paging?.next;
        if (!next) break;
        url = new URL(next);
      }
      return out;
    }

    async function drawPinsForView() {
      if (!TOKEN || !SHOW_PINS) return;
      status("Loading user pins in view…");
      try {
        const images = await fetchImagesInBbox({ bbox: bboxFromMap(map) });
        pinLayer.clearLayers();
        for (const img of images) {
          const coords = img?.computed_geometry?.coordinates; // [lon, lat]
          if (!coords) continue;
          const latlng = [coords[1], coords[0]];
          const c = L.circleMarker(latlng, defaultPinStyle);
          c.on('click', (e) => {
            L.DomEvent.stop(e);               // stop bubbling to map click
            if (viewer) gotoImage(img.id, latlng);
          });
          c.addTo(pinLayer);
        }
        status(images.length ? `Pins: ${images.length}` : "No images in view for this user.");
      } catch (e) { console.error(e); status("Error loading pins."); }
    }

    // Debounce pin requery
    let pinTimer = null;
    map.on('moveend', () => {
      if (!SHOW_PINS) return;
      clearTimeout(pinTimer);
      pinTimer = setTimeout(drawPinsForView, 350);
    });

    // Background map click => nearest image
    map.on('click', async (e) => {
      if (!TOKEN) { status("Add ?token=... to enable image navigation."); return; }
      try {
        status("Finding image near map click…");
        const img = await findImageNear({ lat: e.latlng.lat, lng: e.latlng.lng });
        if (img) { await gotoImage(img.id, [e.latlng.lat, e.latlng.lng]); status(""); }
        else { status("No image found near that point for this user."); }
      } catch (err) { console.error(err); status("Error searching for image near click."); }
    });

    // Mapillary viewer
    let viewer = null;
    let navLock = 0;     // prevents click races
    let yawTimer = null; // live yaw watcher
    let lastYaw = null;

    // Read yaw + FOV from the viewer (supports multiple MJS builds) and update currentFovDeg
    async function readViewerYawFov() {
      try {
        // Prefer dedicated getter if present
        let fovDeg = null;
        if (typeof viewer?.getFieldOfView === 'function') {
          let f = viewer.getFieldOfView(); // may be deg or rad
          fovDeg = (typeof f === 'number' && f <= Math.PI * 2) ? (f * 180 / Math.PI) : f;
        }

        let yawDeg = null;
        if (typeof viewer?.getState === 'function') {
          const st = await viewer.getState();
          let y = st?.pov?.yaw ?? st?.bearing ?? null;
          let f = st?.pov?.fov ?? st?.fov ?? null;
          if (typeof y === 'number' && Math.abs(y) <= Math.PI * 2) y = y * 180 / Math.PI;
          if (typeof f === 'number' && f <= Math.PI * 2) f = f * 180 / Math.PI;
          if (y != null) yawDeg = ((y % 360) + 360) % 360;
          if (fovDeg == null && f != null) fovDeg = f;
        } else if (typeof viewer?.getPointOfView === 'function') {
          const pov = viewer.getPointOfView();
          let y = pov?.yaw, f = pov?.fov;
          if (typeof y === 'number' && Math.abs(y) <= Math.PI * 2) y = y * 180 / Math.PI;
          if (typeof f === 'number' && f <= Math.PI * 2) f = f * 180 / Math.PI;
          if (y != null) yawDeg = ((y % 360) + 360) % 360;
          if (fovDeg == null && f != null) fovDeg = f;
        }

        if (typeof fovDeg === 'number') {
          fovDeg = Math.min(140, Math.max(10, fovDeg)); // clamp
          currentFovDeg = fovDeg;                       // <-- keep live FOV
        }
        return { yawDeg, fovDeg: currentFovDeg };
      } catch {}
      return { yawDeg: null, fovDeg: currentFovDeg };
    }

    function startYawWatcher() {
      if (yawTimer) clearInterval(yawTimer);
      yawTimer = setInterval(async () => {
        const { yawDeg } = await readViewerYawFov(); // updates currentFovDeg internally
        if (yawDeg == null) return;
        // Only redraw if yaw changed ~1°
        if (lastYaw == null || Math.abs(((yawDeg - lastYaw + 540) % 360) - 180) > 1) {
          lastYaw = yawDeg;
          const pos = marker.getLatLng();
          drawOrientation(pos.lat, pos.lng, yawDeg, currentFovDeg, 50); // <-- live FOV
        }
      }, 150);
    }

    // Clear filters and navigate to an image ID
    async function gotoImage(id, latlngHint) {
      const myLock = ++navLock;
      try { await viewer.setFilter(["all"]); } catch {}
      try {
        await viewer.moveTo(id);
        if (latlngHint) {
          marker.setLatLng([latlngHint[0], latlngHint[1]]);
          if (VIEW !== 'image') map.setView(latlngHint, map.getZoom(), { animate: true });
        }
      } finally {
        if (navLock === myLock) navLock = 0;
      }
    }

    (async function init(){
      if (!TOKEN) {
        status(SHOW_PINS ? "Add ?token=YOUR_TOKEN to enable navigation; pins will not load without a token."
                         : "Map only: add ?view=split (or image) and ?token=YOUR_TOKEN to enable the viewer.");
        return;
      }

      const M = window.Mapillary || window.mapillary || window.mapillaryjs;
      const ViewerCtor = M && M.Viewer;
      if (!ViewerCtor) { status("Mapillary library failed to load."); return; }

      viewer = new ViewerCtor({ container: "mly", accessToken: TOKEN });

      try {
        status("Searching for a nearby image…");
        const start = await findImageNear({ lat: defaults.lat, lng: defaults.lng });
        if (!start) { status(`No imagery by "${defaults.username}" near ${defaults.lat.toFixed(5)}, ${defaults.lng.toFixed(5)}.`); return; }

        await gotoImage(start.id);
        status("");

        // Set initial viewer FOV; live watcher will keep currentFovDeg synced
        try { viewer.setFieldOfView(FOV_DEG_DEFAULT); currentFovDeg = FOV_DEG_DEFAULT; } catch {}

        // Sync map + (initial) orientation when the image changes
        async function syncMap(imageId) {
          try {
            const url = new URL(`https://graph.mapillary.com/${imageId}`);
            url.searchParams.set("fields", "computed_geometry,computed_compass_angle");
            const res = await fetch(url, { headers: { Authorization: `OAuth ${TOKEN}` }});
            if (!res.ok) return;
            const j = await res.json();
            const coords = j?.computed_geometry?.coordinates; // [lon, lat]
            const bearing = j?.computed_compass_angle;        // 0..360
            if (coords && coords.length === 2) {
              const latlng = [coords[1], coords[0]];
              marker.setLatLng(latlng);
              if (VIEW !== 'image') map.setView(latlng, map.getZoom(), { animate: true });
              // Draw once from API bearing; yaw watcher will take over as user pans/zooms
              drawOrientation(latlng[0], latlng[1],
                              typeof bearing === 'number' ? bearing : (lastYaw ?? 0),
                              currentFovDeg, 50);
            }
          } catch {}
        }

        await syncMap(start.id);

        try {
          viewer.on('image', (ev) => {
            if (navLock) return;
            lastYaw = null; // force next redraw
            const id = ev?.image?.id || ev?.imageId || ev?.id;
            if (id) syncMap(id);
          });
        } catch {
          // Fallback polling if event not available
          setInterval(async () => {
            if (navLock) return;
            try { const id = (await viewer.getState?.())?.imageId; if (id) { lastYaw = null; syncMap(id); } } catch {}
          }, 1500);
        }

        // Start live yaw/FOV watcher (updates wedge while you pan/zoom in the viewer)
        startYawWatcher();

        if (SHOW_PINS) drawPinsForView();

      } catch (e) {
        console.error(e);
        status("Error: " + (e?.message || e));
      }
    })();
  </script>
</body>
</html>
