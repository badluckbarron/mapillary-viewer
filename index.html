<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mapillary Split (Viewer + Map)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- MapillaryJS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.css" />
  <script src="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.min.js"></script>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #wrap { height: 100vh; width: 100%; display: grid; grid-template-columns: 1fr 1fr; }
    #mly, #map { height: 100%; width: 100%; }
    #badge { position: absolute; top: 8px; left: 8px; z-index: 500; background: rgba(255,255,255,.9);
             padding: 6px 8px; border-radius: 8px; font: 12px/1.2 system-ui, sans-serif; }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="mly"></div>
    <div id="map"></div>
  </div>
  <div id="badge">User: <b>HKocen</b> • Start image: <b>744575191439794</b></div>

  <script>
    // ==== CONFIG ====
    const ACCESS_TOKEN = "MLY|24840280672250420|6fc0e204403850a11ccc043866f1b01d";
    const START_IMAGE_ID = "744575191439794";
    const USERNAME_FILTER = "HKocen";
    const GRAPH_BASE = "https://graph.mapillary.com";

    // ==== VIEWER ====
    const viewer = new mapillary.Viewer({
      container: "mly",
      accessToken: ACCESS_TOKEN,
      imageId: START_IMAGE_ID,
      component: { cover: true, direction: true, zoom: true, attribution: true }
    });

    // ==== MAP ====
    const map = L.map("map", { zoomControl: true });
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19, attribution: "&copy; OpenStreetMap"
    }).addTo(map);

    const pinsLayer = L.geoJSON(null, {
      pointToLayer: (_, latlng) => L.circleMarker(latlng, { radius: 6, weight: 2 })
    }).addTo(map);
    const cursor = L.circleMarker([0,0], { radius: 8, weight: 3 }).addTo(map);

    // ==== UTILS ====
    async function fetchJSON(url) {
      const r = await fetch(url);
      if (!r.ok) throw new Error(`${r.status} ${r.statusText}: ${url}`);
      return r.json();
    }

    async function getImageLatLng(imageId) {
      const url = `${GRAPH_BASE}/images/${imageId}?fields=id,computed_geometry&access_token=${encodeURIComponent(ACCESS_TOKEN)}`;
      const j = await fetchJSON(url);
      const c = j?.computed_geometry?.coordinates; // [lng, lat]
      if (!c) throw new Error("No geometry for " + imageId);
      return [c[1], c[0]];
    }

    function boundsValid(b) {
      // Leaflet invalid before sizing returns +/- Infinity or zero area
      if (!b) return false;
      const sw = b.getSouthWest(), ne = b.getNorthEast();
      if (!isFinite(sw.lat) || !isFinite(sw.lng) || !isFinite(ne.lat) || !isFinite(ne.lng)) return false;
      return (ne.lat > sw.lat) && (ne.lng > sw.lng);
    }

    function currentBBoxParam() {
      const b = map.getBounds();
      if (!boundsValid(b)) return null;
      const west = b.getWest(), south = b.getSouth(), east = b.getEast(), north = b.getNorth();
      return [west, south, east, north].join(",");
    }

    let pinLoadTimeout = null;
    function schedulePinLoad(delay = 250) {
      clearTimeout(pinLoadTimeout);
      pinLoadTimeout = setTimeout(loadPinsForCurrentView, delay);
    }

    async function loadPinsForCurrentView() {
      const bbox = currentBBoxParam();
      if (!bbox) {
        // Map not ready/sized yet — try again shortly
        schedulePinLoad(300);
        return;
      }

      // Build query with BOTH usernames and bbox (required selector)
      const params = new URLSearchParams({
        fields: "id,computed_geometry",
        limit: "500",
        usernames: USERNAME_FILTER,
        bbox,
        access_token: ACCESS_TOKEN
      });

      try {
        const j = await fetchJSON(`${GRAPH_BASE}/images?${params.toString()}`);
        const features = (j.data || [])
          .filter(d => d?.computed_geometry?.coordinates)
          .map(d => ({
            type: "Feature",
            geometry: { type: "Point", coordinates: d.computed_geometry.coordinates },
            properties: { id: d.id }
          }));

        pinsLayer.clearLayers();
        pinsLayer.addData({ type: "FeatureCollection", features });
        pinsLayer.eachLayer(layer => {
          const id = layer.feature.properties.id;
          layer.on("click", () => viewer.moveTo(id));
          layer.bindTooltip(`Image ${id}`);
        });
      } catch (err) {
        console.warn("Pin load failed:", err.message);
        // Try once more after a short delay in case EXB resized
        schedulePinLoad(500);
      }
    }

    // Viewer -> Map sync
    viewer.on("image", async e => {
      try {
        const latlng = await getImageLatLng(e.imageId);
        cursor.setLatLng(latlng);
        if (!map.getBounds().pad(-0.2).contains(latlng)) {
          map.setView(latlng, Math.max(map.getZoom(), 16));
        }
      } catch (err) {
        console.warn(err.message);
      }
    });

    // Map -> Pin refresh
    map.on("moveend", () => schedulePinLoad(200));

    // Handle EXB embed sizing quirks
    function ensureSizeAndLoad() {
      map.invalidateSize();
      schedulePinLoad(150);
    }
    window.addEventListener("resize", ensureSizeAndLoad);

    // ==== INIT ====
    map.whenReady(async () => {
      try {
        const start = await getImageLatLng(START_IMAGE_ID);
        map.setView(start, 17);
        cursor.setLatLng(start);
      } catch {
        map.setView([37.8, -96], 4);
      }
      // Give EXB a tick to fully lay out, then fetch
      setTimeout(ensureSizeAndLoad, 150);
    });
  </script>
</body>
</html>
